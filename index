dDOCKER CLI COMMANDS

1)docker --version
2)docker pull redis
3)docker run --name my-redis -d redis
4)docker ps
5)docker exec -it my-redis redis-cli
127.0.0.1:6379> SET name "Aditi"
OK
127.0.0.1:6379> GET name
"Aditi"
127.0.0.1:6379> docker stop my-redis
(error) ERR unknown command 'docker', with args beginning with: 'stop' 'my-redis'
127.0.0.1:6379> exit
6)docker start my-redis
7)docker stop my-redis
8) docker rm my-redis
9)docker rmi redis

-------------------------------------------------------------------------------------------------------------------------------------------------------------
WORKING WITH DOCKER FILESe

1) On desktop create a folder C:\DockerProj\redis and open in gitbash
2)nano Dockerfile
3)FROM redis:latest
  CMD ["redis-server"] and then ctrl o enter and ctrl x
4)docker build -t redisnew .
5)docker run --name myredisnew -d redisnew
6)docker ps
7)docker stop myredisnew
8)docker login
9)docker ps -a
10)docker commit <containerid> that u created recently aditiv/redis1
11)docker images
12)docker push aditiv/redis1
13)docker pull aditiv/redis1
14)docker run --name myredis -d aditiv/redis
15)docker exec -it myredis redis-cli
127.0.0.1:6379> SET name "Aditi"
OK
127.0.0.1:6379> GET name
"Aditi"
127.0.0.1:6379> exit
16)docker stop myredis
17)docker rm <containerid>
18)docker rmi aditiv/redis1
19)docker ps -a
20)docker logout
------------------------------------------------------------------------------------------------------------------------------------------------------------SCRIPTED PIPELINE

-> Open Jenkins Dashboard click on new item and give a name and select pipeline project
-> Copy this code in script

pipeline {
    agent any

    tools {
        maven 'MAVEN_HOME'
    }

    stages {

        stage('git repo & clean') {
            steps {
                bat "rmdir /s /q webmvn || exit 0"
                bat "git clone https://github.com/ADITI12-coder/webmvn.git"
                bat "mvn clean -f webmvn/pom.xml"
            }
        }

        stage('install') {
            steps {
                bat "mvn install -f webmvn/pom.xml"
            }
        }

        stage('test') {
            steps {
                bat "mvn test -f webmvn/pom.xml"
            }
        }

        stage('package') {
            steps {
                bat "mvn package -f webmvn/pom.xml"
            }
        }

    }
}

-> Click apply and save and then go for build now and in last successful build you will find the console output.
------------------------------------------------------------------------------------------------------------------------------------------------------------
MINIKUBE(Open terminal and run)

->minikube start
->kubectl create deployment mynginx --image=nginx if already created then kubectl set image deployment/mynginx nginx=nginx:latest
->kubectl get deployments
->kubectl get pods
->kubectl describe pods
->kubectl expose deployment mynginx --type=NodePort --port=80 --target-port=80
->kubectl scale deployment mynginx --replicas=4
->kubectl get service myngnix
->kubectl port-forward svc/mynginx 8081:80
->Access via http://localhost:8081

NAGIOS(open terminal and run)
->docker pull jasonrivers/nagios:latest
->docker run --name nagiosdemo -p 8888:80 jasonrivers/nagios:latest
->Open your browser and navigate to:http://localhost:8888
	Login Credentials:
	Username: nagiosadmin
	Password: nagios
	Once logged in, explore:
	Hosts: View systems being monitored.
	Services: Check tasks being monitored (e.g., CPU usage).
	Alerts: Access recent notifications.

->docker stop nagiosdemo
->docker rm nagiosdemo
->docker images
->docker rmijasonrivers/nagios:latest
------------------------------------------------------------------------------------------------------------------------------------------------------------
AWS

->Go to course invitation mail and click on start
->Opens the aws academy, select the student login and enter the email and password details 
->Click on Modules
->Scroll down and select Lunch AWS Academy Lab-
->Click on start Lab and wait AWS becomes from red to green AWS
->Click on EC2 to create instance.Click on Launch Instance
Stage 1  --Name (Giving name to the machine) ubuntu 
Stage 2  -- Select AMI  ( Note: Select free tier eligible ) ubuntu server
Stage 3   --  Architecture as 64-bit
Stage 4  --  Instance type ----  t2.micro(default 1 CPU,1 GB RAM)
Stage 5  --  Create a new keypair---a keypair will downloaded  with extension .pem .Store key in folder AWS
Stage 6  -- Network Setting ----Create Security group  --  ( It deals with ports )
(Note for understanding We have 0 to 65535 ports. Every port is dedicated to special purpose)		
HERE select https and http (which allow to load your web pages while execution)
Stage 7 -- Storage - 8GB ( Observation - we have root - it is same as C Drive) it default 8 GB
Stage 8 --- click on launch instance
Now click on the instances
You have to get 2 tests passes. 
Important:---- Now check the box and click on connect.
Do this step:---once it is created select that instance 
(Tick in checkbox) and click on connect
Step 4: Now you can connect local system to server (EC2 instance) using secure shell SSH.
Here copy the ssh – i command from SSH client connect tab and paste later
Open Powershell in administrative mode and navigate to that path. 
Type:   cd < path> 
Go to SSh and copy the command ssh which is present at the below
sudo apt update
sudo apt-get install docker.io
sudo apt install git
Sudo apt install nano
Step a: Create basic index.html file in folder Example and save it
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Hello from AWS</title>
</head>
<body>
    <h1>Hello from AWS</h1>
</body>
</html>
Step b: Open git Bash in folder Example by right clicking with mouse
Step c: In git bash run the following commands
git init
git add .
Git commit –m “first commit”
Create git repository (here with name AWS) in GitHub
Copy command one by one from above repository and run as below
git branch –M main
git remote add origin <https url>
git push –u origin main
Step f:  refresh repository and You can now see index.html in GitHub
Step g:  Copy http path.Step h:  Clone the repository with copied http path by command in command prompt git clone <copied http url>
Step i:  Navigate to the cloned folder. Type cd AWS as below, next ls to 
Step j:  create Dockerfile in above command prompt in ububtu ie in power shell Nano Dockerfile
FROM nginx:alpine
COPY . /usr/share/nginx/html ctrl o enter ctrl x
sudo docker build –t mywebapp .
sudo docker run –d –p 80:80 mywebapp
Go to instances and click on instance here
Copy public ipv4 address
Paste it in the browser to get below output
Note : if https :__ won’t work then type just http:___
------------------------------------------------------------------------------------------------------------------------------------------------------------

Nagios in Docker
Pull image
docker pull jasonrivers/nagios:latest
Run Nagios
docker run --name nagiosdemo -p 8888:80 jasonrivers/nagios:latest
Open browser
Go to:
http://localhost:8888
Login:
•	username: nagiosadmin
•	password: nagios
stopping: docker stop nagiosdemo
________________________________________
JENKINS FREESTYLE JAVA PROJECT:

Step 1: Open Jenkins (localhost:8080)
├── Click on "New Item" (left

STEP2:Create Freestyle Project (e.g., MavenJava_Build)
├── Enter project name (e.g., MavenJava_Build)
├── Click "OK" └── Configure the project:
├── Description: "Java Build demo" ├── Source Code Management:
└── Git repository URL: [GitMavenJava repo URL]
├── Branches to build: */Main or */master
└── Build Steps:
├── Add Build Step -> "Invoke top-level Maven targets" └── Maven version: MAVEN_HOME
└── Goals: clean
├── Add Build Step -> "Invoke top-level Maven targets" └── Maven version: MAVEN_HOME
└── Goals: install
└── Post-build Actions:
├── Add Post Build Action -> "Archive the artifacts" └── Files to archive: **/*
├── Add Post Build Action -> "Build other projects" └── Projects to build: MavenJava_Test
└── Trigger: Only if build is stable
└── Apply and Save

Step 3: Create Freestyle Project (e.g., MavenJava_Test)
├── Enter project name (e.g., MavenJava_Test)
├── Click "OK" └── Configure the project:
├── Description: "Test demo" ├── Build Environment:
└── Check: "Delete the workspace before build starts" ├── Add Build Step -> "Copy artifacts from another project" └── Project name: MavenJava_Build
└── Build: Stable build only // tick at this
└── Artifacts to copy: **/*
├── Add Build Step -> "Invoke top-level Maven targets" └── Maven version: MAVEN_HOME
└── Goals: test
└── Post-build Actions:
├── Add Post Build Action -> "Archive the artifacts" └── Files to archive: **/*
└── Apply and Save

└── Step 4: Create Pipeline View for Maven Java project
├── Click "+" beside "All" on the dashboard
├── Enter name: MavenJava_Pipeline
├── Select "Build pipeline view" // tick here
|--- create
└── Pipeline Flow:
├── Layout: Based on upstream/downstream relationship
├── Initial job: MavenJava_Build
└── Apply and Save Ok
===========================

WEB PROJECT:

 Step 1: Open Jenkins (localhost:8080)
├── Click on "New Item" (left side menu)

 Step 2: Create Freestyle Project (e.g., MavenWeb_Build)
├── Enter project name (e.g., MavenWeb_Build)
├── Click "OK" └── Configure the project:
├── Description: "Web Build demo" ├── Source Code Management:
└── Git repository URL: [GitMavenWeb repo URL]
├── Branches to build: */Main or master
└── Build Steps:
├── Add Build Step -> "Invoke top-level Maven targets" └── Maven version: MAVEN_HOME
└── Goals: clean
├── Add Build Step -> "Invoke top-level Maven targets" └── Maven version: MAVEN_HOME
└── Goals: install
└── Post-build Actions:
├── Add Post Build Action -> "Archive the artifacts" └── Files to archive: **/*
├── Add Post Build Action -> "Build other projects" └── Projects to build: MavenWeb_Test
└── Trigger: Only if build is stable
└── Apply and Save

 Step 3: Create Freestyle Project (e.g., MavenWeb_Test)
├── Enter project name (e.g., MavenWeb_Test)
├── Click "OK" └── Configure the project:
├── Description: "Test demo"
├── Build Environment:
└── Check: "Delete the workspace before build starts" ├── Add Build Step -> "Copy artifacts from another project" └── Project name: MavenWeb_Build
└── Build: Stable build only
└── Artifacts to copy: **/*
├── Add Build Step -> "Invoke top-level Maven targets" └── Maven version: MAVEN_HOME
└── Goals: test
└── Post-build Actions:
├── Add Post Build Action -> "Archive the artifacts" └── Files to archive: **/*
├── Add Post Build Action -> "Build other projects" └── Projects to build: MavenWeb_Deploy
└── Apply and Save

Step 4: Create Freestyle Project (e.g., MavenWeb_Deploy)
├── Enter project name (e.g., MavenWeb_Deploy)
├── Click "OK" └── Configure the project:
├── Description: "Web Code Deployment"
├── Build Environment:
└── Check: "Delete the workspace before build starts" ├── Add Build Step -> "Copy artifacts from another project" └── Project name: MavenWeb_Test
└── Build: Stable build only
└── Artifacts to copy: **/*
└── Post-build Actions:
├── Add Post Build Action -> "Deploy WAR/EAR to a container" └── WAR/EAR File: **/*.war
└── Context path: Webpath
└── Add container -> Tomcat 9.x remote
└── Credentials: Username: admin, Password: 1234 ── Tomcat URL: https://localhost:8085/
└── Apply and Save

─ Step 5: Create Pipeline View for MavenWeb
├── Click "+" beside "All" on the dashboard
├── Enter name: MavenWeb_Pipeline
├── Select "Build pipeline view" └── Pipeline Flow:
├── Layout: Based on upstream/downstream relationship
├── Initial job: MavenWeb_Build
└── Apply and Save

Step 6: Run the Pipeline and Check Output
├── Click on the trigger “RUN” to run the pipeline
Note:
1. After Click on Run -> click on the small black box to open the console to checkif thebuild is success
2. Now we see all the build has success if it appears in green color
├── Open Tomcat homepage in another tab
├── Click on the "/webpath" option under the manager app


GIT URL FOR WEB PROJECT https://github.com/archanareddyse/mavenweb.git


===================================================
RUNNING MULTIPLE CONTAINERS USING DOCKER COMPOSE

new folder => docker-compse.yml

docker-compose.yml:
version: '3.8'  # Docker Compose file format version

services:
  wordpress:  # WordPress service
    image: wordpress:latest
    ports:
      - "8082:80"  # Map port 80 of the container to port 8080 of the host
    environment:
      WORDPRESS_DB_HOST: db:3306  # Database host
      WORDPRESS_DB_USER: wordpress
      WORDPRESS_DB_PASSWORD: wordpress
      WORDPRESS_DB_NAME: wordpress
    depends_on:
      - db  # Ensures the db service starts first

  db:  # MySQL service
    image: mysql:5.7
    environment:
      MYSQL_ROOT_PASSWORD: rootpassword
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wordpress
      MYSQL_PASSWORD: wordpress

command:=  docker compose up -d

login into wordpress
===========================================

docker compose flask:

new folder:
app.py
docker-compose.yml
Dockerfile

app.py:
from flask import Flask
app = Flask(__name__)

@app.route("/")
def home():
    return "HELLO hii"

if __name__ == "__main__":
    app.run(host="0.0.0.0", port=5000)

docker-compose.yml:
version: "3.9"

services:
  web:
    build: .
    container_name: flaskapp
    ports:
      - "5000:5000"
    depends_on:
      - redis

  redis:
    image: redis:latest
    container_name: redisdb
    ports:
      - "6379:6379"

Dockerfile:
FROM python:3.10-slim
WORKDIR /app
COPY app.py /app/
RUN pip install flask
CMD ["python", "app.py"]

command in cmd:
docker compose up --build
localhost:5000 in browser
===================================
d)	Create Multi Container of mysql and word press through Docker:

mkdir wordpress-mysql
cd wordpress-mysql
docker-compose.yml
version: '3.8'

services:
  mysql:
    image: mysql:5.7
    container_name: mysql-container
    restart: always
    environment:
      MYSQL_ROOT_PASSWORD: root
      MYSQL_DATABASE: wordpress
      MYSQL_USER: wpuser
      MYSQL_PASSWORD: wppass
    ports:
      - "3306:3306"
    volumes:
      - mysql_data:/var/lib/mysql

  wordpress:
    image: wordpress:latest
    container_name: wordpress-container
    restart: always
    depends_on:
      - mysql
    ports:
      - "8080:80"
    environment:
      WORDPRESS_DB_HOST: mysql
      WORDPRESS_DB_USER: wpuser
      WORDPRESS_DB_PASSWORD: wppass
      WORDPRESS_DB_NAME: wordpress
    volumes:
      - wordpress_data:/var/www/html

volumes:
  mysql_data:
  wordpress_data:
---------------------
 version: "3.9"
 services:
 web:
image: nginx:latest
 ports:- "8080:80"
 db:
 image: postgres:15
 environment:
 POSTGRES_USER: demo
 POSTGRES_PASSWORD:demo
 POSTGRES_DB: demo_db
---------------------------------
docker compose up -d
docker ps
localhost:8080
